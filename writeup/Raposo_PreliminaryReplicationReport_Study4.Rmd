---
title: "Replication Report" 
author: "Sarah Raposo"
date: "March 16, 2016"
output: html_document
---

#### Replication of "When Does the Future Begin? Time Metrics Matter, Connecting Present and Future Selves" (Study 4) by Lewis & Oyserman (2015, *Psychological Science*)

<center>Neil A. Lewis, Jr. & Daphna Oyserman
<br><a href="mailto:daphna.oyserman@gmail.com">daphna.oyserman@gmail.com</a></center>

<br><br>Link to testable replication paradigm: https://web.stanford.edu/~sraposo/experiment/LewisTimeMetrics.html

<br><br><center>**Introduction**</center>

<br> &nbsp; &nbsp; &nbsp; &nbsp; People do not save enough for retirement. This may be in part because retirement feels very far away, especially to young people. Study 4 in this paper aimed to elucidate whether having people think about retirement in terms of fine-grained (e.g., days) vs. gross-grained (e.g., years) time metrics impacts when they think they should begin to save for retirement. A secondary goal was to examine whether people think they should save a different amount for retirement when asked how much they should save incrementally, as a function of the time metric they say (i.e., days or years; "incremental action") or how much they should save overall.

&nbsp; &nbsp; &nbsp; &nbsp; In the original study, the authors found that people who read that retirement would begin in 10,950 days said they would wait *less time* to begin saving for retirement compared to those who read that retirement would begin in 30 years (equivalent to 10,950 days), *F*(1,115) = 7.497, *p* = .007, *d* = 0.51. These analyses controlled for participants' age, education, and income, but also held when not controlling for these variables There was no effect of incremental action condition, nor was there a significant interaction.  

&nbsp; &nbsp; &nbsp; &nbsp; Furthermore, neither time metric condition, nor incremental action condition (i.e., amount they should save daily/yearly vs. overall), had an effect on the amount that participants said they should save for retirement. There was also no significant interaction. These results suggest that having people think about their retirement in terms of days may encourage them to start saving sooner than those who think about their retirement in the traditional time metric of years.

<center>**Methods**</center>

**Power Analysis**

&nbsp; &nbsp; &nbsp; &nbsp; The reported effect size for the original main effect of time metric on when to begin saving while controlling for age, income, and education (**target analysis**) with 122 participants was *d* = 0.51. Post-hoc power calculation indicated that power for the original study was 0.79. Assuming an effect size of *d* = 0.51, I would require *N* = 123 to achieve 80% power, *N* = 164 to achieve 90% power, and *N* = 202 to achieve 95% power. Similar to the original study, I will aim to achieve 80% power and so will require a sample size of *N* = 123. 

**Planned Sample**

&nbsp; &nbsp; &nbsp; &nbsp; Participants in the original study were 127 MTurk workers with U.S. IP addresses, and who ranged in age from 18-61 (*M* = 31.48, *sd* = 10.04). Participants were mostly White (78.0%), most had completed college (92.9%), and earn less than $50,000 (78.7%). This sample appears to be representative of the population of MTurk workers (e.g., Ipeirotis, 2015); thus, I restricted participants to MTurk workers with U.S. IP addresses. I ceased collecting data once I reacheded my planned sample size of 123 + 5% = 130. The additional 5% is to ensure we achieve desired power if some participants do not answer all questions or are excluded based on the criteria below.

**Materials**
<br>&nbsp; &nbsp; &nbsp; &nbsp; **Independent variables.** The two independent variables were time metric and chance for incremental action.
<br>&nbsp; &nbsp; &nbsp; &nbsp; **<i>Time metric.</i>** Time metric was manipulated through framing retirement in either days (fine-grained) or years (gross-grained). Participants were randomly assigned to "read a scenario in which he or she was asked to imagine retiring in either 30 years or 10,950 days" (Lewis & Oyserman, 2015, p. 820).
<br>&nbsp; &nbsp; &nbsp; &nbsp; **<i>Chance for incremental action.</i>** "Because starting to save sooner might involve doing more, we explored whether participants planned to do more by manipulating chance for action (incremental, overall) as a second factor. To do this, we asked a second question: “How much would you save?” In the incremental condition, participants were offered a chance for action using the time-metric condition to which they were randomized. In the overall condition, they were not offered a chance for action." (Lewis & Oyserman, 2015, p. 820)
  
&nbsp; &nbsp; &nbsp; &nbsp; **Dependent variables.** The two dependent variables were when to begin saving for retirement and how much to save.
<br>&nbsp; &nbsp; &nbsp; &nbsp; **<i>When to begin saving for retirement.</i>** When to begin saving was assessed with a single item where participants were asked when they should begin to save. The question was framed in terms of the time metric condition to which participants were assigned: "When should you begin saving for retirement? ___ day(s)/year(s)." (Lewis & Oyserman, 2015, Supplemental Materials)
<br>&nbsp; &nbsp; &nbsp; &nbsp; **<i>How much to save for retirement.</i>** Total savings was assessed with a single item where participants were asked how much they should save. The question framing was consistent with the time metric and chance for incremental action conditions to which participants were assigned: "How much should you save (in U.S. dollars) per unit (per day or per year)/overall for your retirement? $___per unit/overall" (Lewis & Oyserman, 2015, Supplemental Materials). In the present study we modified this slightly so that that rather than reading "per unit" the prompt read either "per day", "per year", or "overall" consistent with participants' condition.

&nbsp; &nbsp; &nbsp; &nbsp; **Demographics and covariates.** Demographic items included in all original analyses were age, income, and years of education. It is unclear exactly whether the original authors measured these continuously or categorically; however, the original results were similar whether demographic covariates were controlled for or not, so I do not anticipate that my form of measurement will have an impact on the results. I measured age with an open-ended question, gender, race, education using categories (high school diploma or less, some college or technical school, college degree, some post-graduate, post-graduate degree), and for granularity will measure income with a categorical question beginning with <$20,000 at $10,000 increments until $100,000+. 
  
**Procedure**

&nbsp; &nbsp; &nbsp; &nbsp; Participants were randomly assigned to either the *fine-grained* or *gross-grained* time metric condition, and to either the *chance for incremental action* or *no chance for incremental action* (overall savings) condition. First, participants read a consent form and provided their consent by continuing onto the survey. Next, they read the retirement scenario, responded to the question about when to begin saving for retirement, and then the question about how much to save for their retirement (all consistent with their assigned condition). Finally, participants responded to the demographic questions.

**Analysis Plan**

&nbsp; &nbsp; &nbsp; &nbsp; The authors excluded five participants who gave responses that fell > 3 *sd* from the mean on *when* to save. They also excluded 1 additional individual. It is unclear why this was, but was likely due to missing data. Following this approach, I excluded participants whose responses fell > 3 *sd* from the mean of when to save or who did not respond to the two items of interest. I also excluded data from participants who indicated that they would wait to begin saving longer than the prompt indicated (e.g., longer than 30 years in the gross-grained condition).

&nbsp; &nbsp; &nbsp; &nbsp; I began by visualizing my data by using histograms and boxplots (to examine distributions and detect outliers). Next, I used bar plots and line graphs to better visualize my data by condition. 

&nbsp; &nbsp; &nbsp; &nbsp; To answer the main research questions, I ran 2 regression models to examine the interactive effects of time metric and incremental action on: a) when to begin saving (**target analysis**), b) savings amount natural log-transformed (base e; secondary analysis). I will run both models with and without demographic covariates (age, education, income) consistent with the original paper (the target analysis included the demographic covariates). To further explore the data, I also ran a regression model on total savings amount. 

&nbsp; &nbsp; &nbsp; &nbsp; Because my sample means may differ from those of the original I compared the group means I obtain from my sample on the 2 dependent variables to those obtained in the original study. To further explore the data I also examined the relationship between when to save and savings amount in my sample and explored whether there were relationships between the two dependent variables and demographic covariates. In the original study, only income was found to be positively associated with amount to save. 

**Differences from the Original Study**

&nbsp; &nbsp; &nbsp; &nbsp; Sample setting (MTurk) and overall demographics are expected to be similar to the original study (although the authors do not report full demographics, only % White, % making less than $50,000, etc.). I do not anticipate that any differences in demographic measurement will have an impact on the results because the original results held whether controlling for demographics or not. Another minor difference is that I will slightly modify how I ask for responses for the "when to save" question. To make the question clearer to participants, rather than ask for responses as "per unit" in the incremental action condition, I asked for responses "per day" or "per year" consistent with their condition.

-----

<center>**Results**</center>

**Data preparation**

```{r warning = FALSE, message = FALSE}
rm(list=ls())
library(rjson)
library(plyr)
library(dplyr)
library(tidyr)
library(stringr)
library(splitstackshape)
library(ggplot2)
library(knitr)

#Loading helpers
sem <- function(x) {sd(x, na.rm=TRUE) / sqrt(length(x))}
ci95 <- function(x) {sem(x) * 1.96}
theme_set(theme_linedraw())

path <- "~/Desktop/sraposoProject/ignore/mturk/"
files <- dir(paste0(path,"production-results/"), 
             pattern = "*.json")
d.raw <- data.frame()

for (f in files) {
  jf <- paste0(path, "production-results/", f)
  jd <- fromJSON(paste(readLines(jf), collapse=""))
  id <- data.frame(workerid = jd$WorkerId, 
                   ans = jd$answers)
  d.raw <- bind_rows(d.raw, id)
}
```

```{r warning = FALSE, message = FALSE, echo = FALSE}

#removing "ans.data." from all variable names
names(d.raw) <- gsub("ans.data.", "", names(d.raw))

d0 <- d.raw %>% 
  select(c(workerid, condition, timeMetric, incrAction, rt.2, rt.3),
         contains("responses")) %>% 
  rename(delay.rt = rt.2,
         savings.rt = rt.3,
         delaytime = responses,
         savings = responses.1,
         age = responses.2,
         demos = responses.3,
         comments = responses.4) %>%
  mutate(workerid = as.factor(workerid),
         condition = as.factor(condition),
         timeMetric = as.factor(timeMetric),
         incrAction = as.factor(incrAction))

#cleaning json responses
d0$delaytime <- gsub("Q0", "", d0$delaytime) #removing Q0 from responses
d0$delaytime = gsub("([.])|[[:punct:]]", "\\1", d0$delaytime) #removing all punctuation except .
d0$savings <- gsub("Q0", "", d0$savings) #removing Q0 from responses
d0$savings = gsub("([.])|[[:punct:]]", "\\1", d0$savings) #removing all punctuation except "."
d0$age <- gsub("Q0", "", d0$age) #removing Q0 from responses
d0$age = gsub("([.])|[[:punct:]]", "\\1", d0$age) #removing all punctuation except "."
d0$demos <- gsub("Q0", "", d0$demos) #removing Q0 from responses
d0$demos = gsub("([.$,-])|[[:punct:]]", "\\1", d0$demos) #removing all punctuation except "."

#adding separators in between demographic responses
d0$demos <- gsub(",Q1", "_", d0$demos) 
d0$demos <- gsub(",Q2", "_", d0$demos)
d0$demos <- gsub(",Q3", "_", d0$demos)
d0$comments <- gsub("Q0", "", d0$comments) 
d0$comments <- gsub("Q1", "_", d0$comments) 
d0 = as.data.frame(cSplit(d0, "demos", sep = "_", direction = "wide"))
d0 = as.data.frame(cSplit(d0, "comments", sep = "_", direction = "wide"))

#Renaming demographic variables
d.demos <- d0 %>% 
  rename(gender = demos_1,
         edu = demos_2,
         race = demos_3,
         income = demos_4,
         purpose = comments_1,
         comments = comments_2) %>%
  mutate(gendercat = as.factor(gender),
         educat = as.factor(edu),
         racecat = as.factor(race),
         incomecat = as.factor(income))

# Cleaning up factor labels 
d.demos$gendercat = factor(d.demos$gender, labels = c("Female", "Male", "Other", "Decline to state"), levels = c("Female", "Male", "Other", "Decline to state"))
d.demos$educat = factor(d.demos$educat, labels = c("high school diploma or less", "some college or technical school", "college degree", "some post-graduate", "post-graduate degree e.g., Masters, Ph.D., J.D.", "Decline to state"), levels = c("high school diploma or less", "some college or technical school", "college degree", "some post-graduate", "post-graduate degree e.g., Masters, Ph.D., J.D.", "Decline to state"))
d.demos$racecat = factor(d.demos$race, labels = c("White non-Hispanic", "White Hispanic", "Black or African American", "American Indian or Alaska Native", "Asian", "Native Hawaiian or Pacific Islander", "Decline to state"), levels = c("White non-Hispanic", "White Hispanic", "Black or African American", "American Indian or Alaska Native", "Asian", "Native Hawaiian or Pacific Islander", "Decline to state"))
d.demos$incomecat = factor(d.demos$income, labels = c("<$20,000", "$20-$29,999", "$30-$39,999", "$40-$49,999", "$50-$59,999", "$60-$69,999", "$70-$79,999", "$80-$89,999", "$90-$99,999", "$100,000", "Decline to state"), levels = c("<$20,000", "$20-$29,999", "$30-$39,999", "$40-$49,999", "$50-$59,999", "$60-$69,999", "$70-$79,999", "$80-$89,999", "$90-$99,999", "$100,000", "Decline to state"))

d.demos <- d.demos %>% 
  mutate(gender = as.numeric(gendercat),
         edu = as.numeric(educat),
         race = as.numeric(racecat),
         income = as.numeric(incomecat))

# Writing tidy file
setwd("~/Desktop/sraposoProject/ignore/data")
write.csv(d.demos, file = "LewisReplication_PilotData_Tidy.csv") #Check excel file for any issues with data

```


```{r warning = FALSE, message = FALSE, echo = FALSE}

#Reading in tidy file
setwd("~/Desktop/sraposoProject/ignore/data")
d0 = read.csv("LewisReplication_PilotData_Tidy.csv", na.strings = c("NA"))
#length(unique(d0$workerid))

# Editing factor structure from tidy file

d0$conditionnum = as.numeric(d0$condition)
d0$educat = factor(d0$educat, levels = c("high school diploma or less", "some college or technical school", "college degree", "some post-graduate", "post-graduate degree e.g., Masters, Ph.D., J.D.", "Decline to state"))
d0$incomecat = factor(d0$incomecat, levels = c("<$20,000", "$20-$29,999", "$30-$39,999", "$40-$49,999", "$50-$59,999", "$60-$69,999", "$70-$79,999", "$80-$89,999", "$90-$99,999", "$100,000", "Decline to state"))
d0$gendercat = factor(d0$gendercat, levels = c("Female", "Male", "Other", "Decline to state"))
d0$racecat = factor(d0$racecat, levels = c("White non-Hispanic", "White Hispanic", "Black or African American", "American Indian or Alaska Native", "Asian", "Native Hawaiian or Pacific Islander", "Decline to state"))


#Converting delaytime to years and savings to total savings. Creating a log(savings) variable to compare to original study

# Raw delay time (days vs. years)
delaytimeraw = d0 %>% 
  group_by(timeMetric) %>%
  summarise(mean=mean(delaytime, na.rm = T), sd=sd(delaytime, na.rm = T), n = sum(!is.na(delaytime)), sem = sem(delaytime))

#Computing delay time in years
d0$delaydiv <- ifelse(d0$timeMetric == "fine", 365, 1) #Creating a denominator, depending on condition
d0$delaytimeyrs = d0$delaytime / d0$delaydiv #Calculating time to wait in years
#range(d0$delaytimeyrs, na.rm = T) #Checking range of new variable
delaytimeyrs = d0 %>% 
  group_by(timeMetric) %>%
  summarise(mean=mean(delaytimeyrs, na.rm = T), sd=sd(delaytimeyrs, na.rm = T), n = sum(!is.na(delaytimeyrs)), sem = sem(delaytimeyrs))

# Raw savings (per day vs per year vs overall)
savingraw = d0 %>% 
  group_by(incrAction) %>%
  summarise(mean=mean(savings, na.rm = T), sd=sd(savings, na.rm = T), n = sum(!is.na(savings)), sem = sem(savings))

#Computing total savings

d0$savingmult <- ifelse((d0$timeMetric == "fine") & (d0$incrAction) == "incremental", 10950, 
                       ifelse((d0$timeMetric == "gross") & (d0$incrAction == "incremental"), 30, 1)) #Creating multiplier, depending on condition (only necessary for incremental action conditions)
d0$savingtot = d0$savings * d0$savingmult #Calculating overall retirement savings

#range(d0$savingtot, na.rm = T) #Checking range
#str(d0$savingtot)

savingtot = d0 %>% 
  group_by(incrAction) %>%
  summarise(mean=mean(savingtot, na.rm = T), sd=sd(savingtot, na.rm = T), n = sum(!is.na(savingtot)), sem = sem(savingtot))

d0$logsavingtot = log(d0$savingtot) #Creating log(savings) using natural log
#range(d0$logsavingtot) #checking range

d0$age = as.numeric(d0$age)

```


```{r warning = FALSE, message = FALSE, echo = FALSE, eval = FALSE, fig.width=4, fig.height=3}
#First, I will visualize the distribution of responses overall and by condition using histograms.

#Histogram of years to wait
qplot(delaytimeyrs, data = d0) +
  xlab("Years to Wait")

#Histogram of years to wait by time metric condition
qplot(delaytimeyrs, data = d0) +
  facet_wrap(~timeMetric) +
  xlab("Years to Wait")

#Histogram of log(total savings)
qplot(logsavingtot, data = d0) +
  xlab("Total Retirement Savings - Log")

#Histogram of log(total savings) by condition
qplot(logsavingtot, data = d0) +
  facet_wrap(~condition) +
  xlab("Total Retirement Savings - Log")


```


```{r warning = FALSE, echo = FALSE, eval = FALSE, fig.width=4, fig.height=3}
#To further visualize the response distribution, creating boxplots of the main dependent variables: how long to delay saving, and how much to save in total. These boxplots are for the overall data and also broken down by condition.

#When to save by time metric condition
ggplot(d0, aes(factor(timeMetric), delaytimeyrs)) +
  geom_boxplot() +
  xlab("Time metric condition") +
  ylab("Delay to start saving (years)")
#delay1 #will print outliers, if they exist

#When to save across all 4 conditions
ggplot(d0, aes(factor(condition), delaytimeyrs)) +
  geom_boxplot() +
  xlab("Condition (time metric and incremental action)") +
  ylab("Delay to start saving (years)")
#delay2 #print outliers

#How much to save across all 4 conditions
ggplot(d0, aes(factor(condition), savingtot)) +
  geom_boxplot() +
  xlab("Condition (time metric and incremental action)") +
  ylab("Total savings ($)")
#saving1 #print outliers

#How much to save (log) across all 4 conditions
ggplot(d0, aes(factor(condition), logsavingtot)) +
  geom_boxplot() +
  xlab("Condition (time metric and incremental action)") +
  ylab("Total savings - natural log($)")
#saving2 #print outliers
```



```{r exclusions, warning = FALSE}

# Sanity check
#range(d0$delaytime[d0$timeMetric == "fine"], na.rm = T) #can't wait more than 10950 days
#range(d0$delaytime[d0$timeMetric == "gross"], na.rm = T) #can't wait more than 30yrs

#Removing anyone who had "NA" on the main DV
d1 = d0[!is.na(d0$delaytimeyrs), ]

#Creating binary variable for anyone who was >3SD from the mean of the main DV (when to begin saving)
d1$delayexclude <- ifelse(d1$delaytimeyrs > (mean(d1$delaytimeyrs, na.rm = T) + 3*sd(d1$delaytimeyrs, na.rm = T)), "exclude",
                          ifelse(d1$delaytimeyrs == "NA", "exclude", "include")) 
tdelayexcl = table(d1$delayexclude)

#Creating binary variable for anyone who would wait more than 10950 days in fine condition or 30 years in gross-grained condition
d1$delayrawexclude1 <- ifelse((d1$timeMetric == "fine" & d1$delaytime > 10950), "exclude", "include") 
tdelayexclraw1 = table(d1$delayrawexclude1)
d1$delayrawexclude2 <- ifelse((d1$timeMetric == "gross" & d1$delaytime > 30), "exclude", "include") 
tdelayexclraw2 = table(d1$delayrawexclude2)

#Overall exclusion variable based on 3 variables above (if anyone was excluded based on any of the 3 rules above)
d1$exclude <- ifelse((d1$delayexclude == "exclude" | d1$delayrawexclude1 == "exclude" | d1$delayrawexclude2 == "exclude"), "exclude", "include") 
tableexcl = table(d1$exclude)

#only keeping those cases should not be excluded based on criteria above
d = d1[d1$exclude == "include",] 
ndiff = length(unique(d0$workerid))-length(unique(d$workerid)) #total number of participants excluded
nincl = length(unique(d$workerid)) #final sample size
```
&nbsp; &nbsp; &nbsp; &nbsp; Participants were `r length(unique(d.raw$workerid))` MTurk workers. In total we excluded data from `r ndiff` participants who did not respond to the dependent variables, who reported they would wait longer than 10,950 days to begin saving in the fine-grained condition, or longer than 30 years in the gross-grained condition, and those who gave responses that fell more than three standard deviations above the mean on the dependent variables. Our final sample size was `r nincl` participants.

**Main analyses**

&nbsp; &nbsp; &nbsp; &nbsp; To visualize the critical analysis I plotted group means for how long participants say they will wait to begin saving by time metric condition. To visualize the secondary analysis I plotted group means for how much participants think they should save for retirement by time metric and incremental action condition. 

&nbsp; &nbsp; &nbsp; &nbsp; Consistent with the original results, I expected that people in the fine-grained condition will want to wait less time to begin saving for retirement compared to those in the gross-grained condition. All error bars reflect +/-1 standard error.

```{r warning = FALSE, message = FALSE, fig.width=4, fig.height=3.5}
delaytimemean = d %>% 
  group_by(timeMetric) %>%
  summarise(mean=mean(delaytimeyrs, na.rm = T), sd=sd(delaytimeyrs, na.rm = T), n = sum(!is.na(delaytimeyrs)), sem = sem(delaytimeyrs))
#delaytimemean

ggplot(delaytimemean[!is.na(delaytimemean$timeMetric), ], aes(x=timeMetric, y = mean)) + 
  geom_bar(position=position_dodge(), stat="identity",
           colour="black", # Use black outlines,
           size=.3) +
  geom_errorbar(aes(ymin=mean-sem, ymax=mean+sem),
                size=.4,
                width=.1,                    # Width of the error bars
                position=position_dodge(.9)) +
  coord_cartesian(ylim=c(0,2.5)) + #to match original study
  xlab("Time metric condition") +
  ylab("Delay to start saving (years)") +
  ggtitle("Years to Delay Retirement Saving by \n Condition - Replication") +
  theme_linedraw(base_size = 12)

# plotting means and standard errors for original results
origdelay <- matrix(c(.45, 1.70, .40, .35, "fine", "gross"), ncol=3)
colnames(origdelay) <- c('mean', 'se', 'condition')
delaytable <- data.frame(origdelay)
delaytable$mean = as.numeric(as.character(delaytable$mean))
delaytable$se = as.numeric(as.character(delaytable$se))

ggplot(delaytable, aes(x = condition, y = mean)) + 
  geom_bar(position=position_dodge(), stat="identity",
           colour="black", # Use black outlines,
           size=.3) +
  geom_errorbar(aes(ymin=mean-se, ymax=mean+se),
              size=.4,
              width=.1,                    # Width of the error bars
              position=position_dodge(.9)) +
  coord_cartesian(ylim=c(0,2.5)) + 
  xlab("Time metric condition") +
  ylab("Delay to start saving (years)") +
  ggtitle("Years to Delay Retirement Saving by \n Condition - Original") +
  theme_linedraw(base_size = 12)
```


&nbsp; &nbsp; &nbsp; &nbsp; I also plotted how much people report they should save for retirement (natural log transformed) by time metric and incremental action conditions, consistent with the original paper.

```{r warning = FALSE, message = FALSE, fig.width=4.5, fig.height=3.5}

#Creating graph from replication data
logsavingtotmean = d %>% 
  group_by(timeMetric, incrAction) %>%
  summarise(mean=mean(logsavingtot, na.rm = T), sd=sd(logsavingtot, na.rm = T), n = sum(!is.na(logsavingtot)), sem = sem(logsavingtot))
#logsavingtotmean

ggplot(logsavingtotmean[!is.na(logsavingtotmean$timeMetric), ], aes(x=timeMetric, y = mean, fill = incrAction)) + 
  geom_bar(position=position_dodge(), stat="identity",
           colour="black", # Use black outlines,
           size=.3) +
  geom_errorbar(aes(ymin=mean-sem, ymax=mean+sem),
                size=.4,
                width=.2,                    # Width of the error bars
                position=position_dodge(.9)) +
  guides(fill=guide_legend(title="Incremental action")) +
  coord_cartesian(ylim=c(11, 13.5)) + #to match original graph
  xlab("Time metric condition") + 
  ylab("Log total retirement savings ($)") +
  ggtitle("Retirement Savings (log) by \n Condition - Replication") +
  theme_linedraw(base_size = 12)

# Creating graph based on original sample means and standard errors
origsaving <- matrix(c(12.32, 12.28, 12.39, 13.02, 0.25, 0.30, 0.20, 0.25, "fine", "fine", "gross", "gross", "incremental", "overall", "incremental", "overall"), ncol=4)
colnames(origsaving) <- c('mean', 'se', 'timemetric', 'action')
savingtable <- data.frame(origsaving)
savingtable$timemetric = factor(savingtable$timemetric, labels = c("fine", "gross"),levels = c("fine", "gross"))
savingtable$action = factor(savingtable$action, labels = c("incremental", "overall"), levels = c("incremental", "overall"))
savingtable$mean = as.numeric(as.character(savingtable$mean))
savingtable$se = as.numeric(as.character(savingtable$se))

ggplot(savingtable, aes(x = timemetric, y = mean, fill = action)) + 
  geom_bar(position=position_dodge(), stat="identity",
           colour="black", # Use black outlines,
           size=.3) +
  geom_errorbar(aes(ymin=mean-se, ymax=mean+se),
            size=.4,
            width=.2,                    # Width of the error bars
            position=position_dodge(.9)) +
  coord_cartesian(ylim=c(11,13.5)) + #from original graph
  xlab("Time metric condition") +
  ylab("Log total retirement savings ($)") +
  ggtitle("Retirement Savings (log) by \n Condition - Original") +
  theme_linedraw(base_size = 12)
```


#### <br>Critical analysis: Effect of time metric and incremental action on when to save

&nbsp; &nbsp; &nbsp; &nbsp; Consistent with the graphs above, there were two main analyses in the original paper. The **critical analysis of interest** was an analysis of covariance on *when to begin saving for retirement* that included time metric and incremental action as independent variables and age, income, and education as covariates. The authors found only a main effect of time metric condition on when to begin saving.

&nbsp; &nbsp; &nbsp; &nbsp; The secondary analysis of interest was an analysis of covariance on *how much to save for retirement* that included time metric and incremental action as independent variables and age, income, and education as covariates. There were no significant effects of time metric condition or incremental action on amount to save. For both dependent variables the authors ran the test with demographic controls (age, education, income) and without, and the results were the same. Only income significantly predicted amount to save, but controlling for demographics did not change the interpretation of either outcome.

&nbsp; &nbsp; &nbsp; &nbsp; Consistent with the original paper, for my critical analysis I expect a main effect of time metric such that people in the fine-grained condition would begin to save sooner than those in the gross-grained condition. I expect a similar effect regardless of whether I control for demographics.

```{r critical analysis, warning = FALSE, message = FALSE}
#controlling for demographics - critical analysis
rs.lmdelaytot.cov = lm(delaytimeyrs ~ age + income + edu + timeMetric * incrAction, d)
delaycovres = anova(rs.lmdelaytot.cov)
Fstat1 = delaycovres[4,4] #time metric
dfnum1 = delaycovres[4,1]
dfdenom1 = rs.lmdelaytot.cov$df.residual
pval1 = delaycovres[4,5]

#no demographic controls
rs.lmdelaytot = lm(delaytimeyrs ~ timeMetric * incrAction, d)
delayres = anova(rs.lmdelaytot)
Fstat2 = delayres[1,4] #time metric
dfnum2 = delayres[1,1]
dfdenom2 = rs.lmdelaytot$df.residual
pval2 = delayres[1,5]

```
For our **critical analysis** the main effect of time metric is: F(`r dfnum1`, `r dfdenom1`) = `r round(Fstat1, 3)`, p = `r round(pval1, 4)` (original results: F(1, 115) = 7.497, p = .007).

When not controlling for demographics, the main effect of time metric is: F(`r dfnum2`, `r dfdenom2`) = `r round(Fstat2, 3)`, p = `r round(pval2, 4)` (original results: F(1, 118) = 7.166, p = .008).


#### <br>Secondary analysis: Effect of time metric and incremental action on how much to save (log transformed)

&nbsp; &nbsp; &nbsp; &nbsp; Consistent with the original paper, I expect no effect of time metric or incremental action on the log-transformed values of how much to save overall for retirement. The result should be the same regardless of whether I control for demographics.

```{r secondary analysis, warning = FALSE, message = FALSE}
#secondary analysis
#controlling for demographics
rs.lmlogsavingstot.cov = lm(logsavingtot ~ age + edu + income + timeMetric * incrAction, d)
savecovres = anova(rs.lmlogsavingstot.cov) 
Fstat3a = savecovres[4,4] #time metric
dfnum3a = savecovres[4,1]
dfdenom3a = rs.lmlogsavingstot.cov$df.residual
pval3a = savecovres[4,5]

Fstat3b = savecovres[5,4] #incrAction
dfnum3b = savecovres[5,1]
dfdenom3b = rs.lmlogsavingstot.cov$df.residual
pval3b = savecovres[5,5]

#no demographic controls
rs.lmlogsavingstot = lm(logsavingtot ~ timeMetric * incrAction, d)
saveres = anova(rs.lmlogsavingstot)
Fstat3c = saveres[1,4] #time metric
dfnum3c = saveres[1,1]
dfdenom3c = rs.lmlogsavingstot$df.residual
pval3c = saveres[1,5]

Fstat3d = saveres[2,4] #incrAction
dfnum3d = saveres[2,1]
dfdenom3d = rs.lmlogsavingstot$df.residual
pval3d = saveres[2,5]

```
For the secondary analysis (controlling for demographics) the main effect of incremental action is: F(`r dfnum3b`, `r dfdenom3b`) = `r round(Fstat3b, 3)`, p = `r round(pval3b, 4)` (original result: p = .227) and the main effect of time metric is: F(`r dfnum3a`, `r dfdenom3a`) = `r round(Fstat3a, 3)`, p = `r round(pval3a, 4)` (p = .164).

When not controlling for demographics, the main effect of incremental action is: F(`r dfnum3d`, `r dfdenom3d`) = `r round(Fstat3d, 3)`, p = `r round(pval3d, 4)` (original result: p = .229) and the main effect of time metric is: F(`r dfnum3c`, `r dfdenom3c`) = `r round(Fstat3c, 3)`, p = `r round(pval3c, 4)` (p = .140).



#### Comparing means from our sample to those in original paper

&nbsp; &nbsp; &nbsp; &nbsp; Because our sample may differ somewhat from the sample in the original paper, it is important to compare sample means. I ran t-tests to compare means of when to start saving in each condition, and how much to save (log transformed) to those in the original paper.

<br>&nbsp; &nbsp; &nbsp; &nbsp; **Delay to begin saving means.**

```{r warning = FALSE, message = FALSE}
delaymeanstab = matrix(c("fine", "gross", .45, 1.70, round(mean(d$delaytimeyrs[d$timeMetric == "fine"]), 2), round(mean(d$delaytimeyrs[d$timeMetric == "gross"]), 2)), ncol = 3)
colnames(delaymeanstab) <- c('condition', 'original', 'replication')
kable(delaymeanstab, format = "markdown", col.names = c('condition', 'original', 'replication'), digits = 3)

# Original and replication means for fine-grained condition
delayyrs.mfine = mean(d$delaytimeyrs[d$timeMetric == "fine"])
delayyrs.sdfine = sd(d$delaytimeyrs[d$timeMetric == "fine"])
delayyrs.nfine = length(d$delaytimeyrs[d$timeMetric == "fine"])
origdelayyrs.mfine = 0.45
origdelayyrs.sdfine = 3.12
origdelayyrs.nfine = 61

# Original and replication means for gross-grained condition
delayyrs.mgross = mean(d$delaytimeyrs[d$timeMetric == "gross"])
delayyrs.sdgross = sd(d$delaytimeyrs[d$timeMetric == "gross"])
delayyrs.ngross = length(d$delaytimeyrs[d$timeMetric == "gross"])
origdelayyrs.mgross = 1.70
origdelayyrs.sdgross = 2.73
origdelayyrs.ngross = 61

# m1, m2: the sample means
# s1, s2: the sample standard deviations
# n1, n2: the same sizes
# m0: the null value for the difference in means to be tested for. Default is 0. 
# equal.variance: whether or not to assume equal variance. Default is FALSE. 
t.test2 <- function(m1,m2,s1,s2,n1,n2,m0=0,equal.variance=FALSE)
{
  if( equal.variance==FALSE ) 
  {
    se <- sqrt( (s1^2/n1) + (s2^2/n2) )
    # welch-satterthwaite df
    df <- ( (s1^2/n1 + s2^2/n2)^2 )/( (s1^2/n1)^2/(n1-1) + (s2^2/n2)^2/(n2-1) )
  } else
  {
    # pooled standard deviation, scaled by the sample sizes
    se <- sqrt( (1/n1 + 1/n2) * ((n1-1)*s1^2 + (n2-1)*s2^2)/(n1+n2-2) ) 
    df <- n1+n2-2
  }      
  t <- (m1-m2-m0)/se 
  dat <- c(m1-m2, se, t, 2*pt(-abs(t),df))    
  names(dat) <- c("Difference of means", "Std Error", "t", "p-value")
  return(dat) 
}

# ttest comparing delay time (years) for fine-grained condition between original and replication
tdelayfine = t.test2(delayyrs.mfine, origdelayyrs.mfine, delayyrs.sdfine, origdelayyrs.sdfine, delayyrs.nfine, origdelayyrs.nfine)

# ttest comparing delay time (years) for gross-grained condition between original and replication
tdelaygross = t.test2(delayyrs.mgross, origdelayyrs.mgross, delayyrs.sdgross, origdelayyrs.sdgross, delayyrs.ngross, origdelayyrs.ngross)

```
When comparing the original and replication means of the fine-grained condition on how long to wait to save for retirement, the results are: t = `r round(tdelayfine[3], 3)`, p = `r round(tdelayfine[4], 3)`. When comparing the original and replication means of the gross-grained condition on how long to wait to save, the results are: t = `r round(tdelaygross[3], 3)`, p = `r round(tdelaygross[4], 3)`.


<br>&nbsp; &nbsp; &nbsp; &nbsp; **Amount to save means.**

```{r warnings = FALSE, message = FALSE}
savingmeanstab = matrix(c("fine", "fine", "gross", "gross", "incremental", "overall", "incremental", "overall", 12.32, 12.28, 12.39, 13.02, round(mean(d$logsavingtot[d$timeMetric == "fine" & d$incrAction == "incremental"]), 2), round(mean(d$logsavingtot[d$timeMetric == "fine" & d$incrAction == "overall"]), 2), round(mean(d$logsavingtot[d$timeMetric == "gross" & d$incrAction == "incremental"]), 2), round(mean(d$logsavingtot[d$timeMetric == "gross" & d$incrAction == "overall"]), 2)), ncol = 4)
colnames(savingmeanstab) <- c('time metric', 'incremental action', 'original', 'replication')
kable(savingmeanstab, format = "markdown", col.names = c('time metric', 'incremental action', 'original', 'replication'), digits = 3)

```

```{r warnings = FALSE, message = FALSE}
# Original and replication means for incremental, fine-grained condition
savingm.incfine = mean(d$logsavingtot[d$timeMetric == "fine" & d$incrAction == "incremental"])
savingsd.incfine = sd(d$logsavingtot[d$timeMetric == "fine" & d$incrAction == "incremental"])
savingn.incfine = length(d$logsavingtot[d$timeMetric == "fine" & d$incrAction == "incremental"])
origsavingm.incfine = 12.32
origsavingsd.incfine = 1.39
origsavingn.incfine = 31

# Original and replication means for overall, fine-grained condition
savingm.overfine = mean(d$logsavingtot[d$timeMetric == "fine" & d$incrAction == "overall"])
savingsd.overfine = sd(d$logsavingtot[d$timeMetric == "fine" & d$incrAction == "overall"])
savingn.overfine = length(d$logsavingtot[d$timeMetric == "fine" & d$incrAction == "overall"])
origsavingm.overfine = 12.28
origsavingsd.overfine = 1.67
origsavingn.overfine = 31

# Original and replication means for incremental, gross-grained condition
savingm.incgross = mean(d$logsavingtot[d$timeMetric == "gross" & d$incrAction == "incremental"])
savingsd.incgross = sd(d$logsavingtot[d$timeMetric == "gross" & d$incrAction == "incremental"])
savingn.incgross = length(d$logsavingtot[d$timeMetric == "gross" & d$incrAction == "incremental"])
origsavingm.incgross = 12.39
origsavingsd.incgross = 1.11
origsavingn.incgross = 31

# Original and replication means for overall, gross-grained condition
savingm.overgross = mean(d$logsavingtot[d$timeMetric == "gross" & d$incrAction == "overall"])
savingsd.overgross = sd(d$logsavingtot[d$timeMetric == "gross" & d$incrAction == "overall"])
savingn.overgross = length(d$logsavingtot[d$timeMetric == "gross" & d$incrAction == "overall"])
origsavingm.overgross = 13.02
origsavingsd.overgross = 1.39
origsavingn.overgross = 31

# ttest comparing log(savings) for incremental, fine-grained condition between original and replication
tsavingincfine = t.test2(savingm.incfine, origsavingm.incfine, savingsd.incfine, origsavingsd.incfine, savingn.incfine, origsavingn.incfine)

# ttest comparing log(savings) for overall, fine-grained condition between original and replication
tsavingoverfine = t.test2(savingm.overfine, origsavingm.overfine, savingsd.overfine, origsavingsd.overfine, savingn.overfine, origsavingn.overfine)

# ttest comparing log(savings) for incremental, gross-grained condition between original and replication
tsavingincgross = t.test2(savingm.incgross, origsavingm.incgross, savingsd.incgross, origsavingsd.incgross, savingn.incgross, origsavingn.incgross)

# ttest comparing log(savings) for overall, gross-grained condition between original and replication
tsavingovergross = t.test2(savingm.overgross, origsavingm.overgross, savingsd.overgross, origsavingsd.overgross, savingn.overgross, origsavingn.overgross)

```
When comparing the original and replication means of the incremental fine-grained condition on natural log-transformed retirement savings, the results are: t = `r round(tsavingincfine[3], 3)`, p = `r round(tsavingincfine[4], 3)`. When comparing the original and replication means of the overall fine-grained condition on natural log-transformed retirement savings, the results are: t = `r round(tsavingoverfine[3], 3)`, p = `r round(tsavingoverfine[4], 3)`.

When comparing the original and replication means of the incremental gross-grained condition on natural log-transformed retirement savings, the results are: t = `r round(tsavingincgross[3], 3)`, p = `r round(tsavingincgross[4], 3)`. When comparing the original and replication means of the overall gross-grained condition on natural log-transformed retirement savings, the results are: t = `r round(tsavingovergross[3], 3)`, p = `r round(tsavingovergross[4], 3)`.

----------

#### Exploratory analyses

**Effect of time metric and incremental action on total savings amount (raw, not log-transformed)**

&nbsp; &nbsp; &nbsp; &nbsp; Because the analyses in the original paper were on the log-transformed data, I am interested in exploring whether there are any effects of time metric or incremental action condition on the raw total amount participants would save for retirement. 

```{r warning = FALSE, message = FALSE, eval = FALSE, fig.width=5, fig.height=3}

#Histogram of total retirement savings
qplot(savingtot, data = d0) +
  xlab("Total Retirement Savings ($)")

#Histogram of total retirement savings by condition
qplot(savingtot, data = d0) +
  facet_wrap(~condition) +
  xlab("Total Retirement Savings ($)")

savingtotmean = d %>% 
  group_by(timeMetric, incrAction) %>%
  summarise(mean=mean(savingtot, na.rm = T), sd=sd(savingtot, na.rm = T), n = sum(!is.na(savingtot)), sem = sem(savingtot))
#savingtotmean

ggplot(savingtotmean[!is.na(savingtotmean$timeMetric), ], aes(x=timeMetric, y = mean, fill = incrAction)) + 
  geom_bar(position=position_dodge(), stat="identity",
           colour="black", # Use black outlines,
           size=.3) +
  geom_errorbar(aes(ymin=mean-sem, ymax=mean+sem),
                size=.4,
                width=.1,                    # Width of the error bars
                position=position_dodge(.9)) +
  guides(fill=guide_legend(title="Incremental action")) +
  xlab("Time Metric Condition") +
  ylab("Total Retirement Savings ($)") +
  ggtitle("Total Retirement Savings by Condition") +
  theme_linedraw(base_size = 11)
```


```{r warning = FALSE, message = FALSE, eval = FALSE}

## Raw savings total

#no demographic controls
rs.lmsavingstot = lm(savingtot ~ timeMetric * incrAction, d); summary(rs.lmsavingstot) 
anova(rs.lmsavingstot)

#controlling for demographics
rs.lmsavingstot.cov = lm(savingtot ~ timeMetric * incrAction + age + edu + income, d); summary(rs.lmsavingstot.cov) 
```


**When to begin saving - visualizing effects across all 4 conditions **

&nbsp; &nbsp; &nbsp; &nbsp; We should also plot when to start saving (in years) across all 4 conditions, rather than only across the time metric conditions (which is consistent with the original paper), to ensure that there were no differences across the incremental action conditions. We would expect that there would be no effect of incremental action condition because this condition was not assigned/did not come into play until after the when to save question was asked.

```{r warning = FALSE, message = FALSE, eval = FALSE, fig.width=5, fig.height=3}
delaytimemean2 = d %>% 
  group_by(timeMetric, incrAction) %>%
  summarise(mean=mean(delaytimeyrs, na.rm = T), sd=sd(delaytimeyrs, na.rm = T), n = sum(!is.na(delaytimeyrs)), sem = sem(delaytimeyrs))
#delaytimemean2

ggplot(delaytimemean2[!is.na(delaytimemean2$timeMetric), ], aes(x=timeMetric, y = mean)) + 
  facet_wrap(~incrAction) +
  geom_bar(position=position_dodge(), stat="identity",
           colour="black", # Use black outlines,
           size=.3) +
  geom_errorbar(aes(ymin=mean-sem, ymax=mean+sem),
                size=.4,
                width=.2,                    # Width of the error bars
                position=position_dodge(.9)) +
    guides(fill=guide_legend(title="Incremental action")) +
#  ylim(c(0,2.5)) + #to match original study
  xlab("Time metric condition") +
  ylab("Delay to start saving (years)") +
  ggtitle("Years to Delay Retirement Saving by Condition") +
  theme_linedraw(base_size = 11)
```

**Examining demographics**

&nbsp; &nbsp; &nbsp; &nbsp;  Demographic factors likely play a role in terms of when and how much people feel they should save, so I may explore the relationship among demographic factors and the two dependent variables in this sample.
```{r demos, message = FALSE, warning = FALSE, eval = FALSE}

# Age
agemean = d %>%
  group_by(timeMetric, incrAction) %>%
  summarise(mean=mean(age, na.rm = T), sd=sd(age, na.rm = T), n = sum(!is.na(age)), se = sd/sqrt(n))
agemean

ggplot(agemean[!is.na(agemean$timeMetric), ], aes(x=timeMetric, y = mean, fill = incrAction)) + 
  geom_bar(position=position_dodge(), stat="identity",
           colour="black", # Use black outlines,
           size=.3) +
  geom_errorbar(aes(ymin=mean-se, ymax=mean+se),
    size=.4,
    width=.2,                    # Width of the error bars
    position=position_dodge(.9)) +
  xlab("Condition") +
  ylab("Mean age") +
  ggtitle("Age by Condition") +
  theme_bw(base_size = 11)

rslm.age = lm(age ~ timeMetric * incrAction, d); summary(rslm.age) 


# Gender

ggplot(d[!is.na(d$gendercat), ], aes(x=condition, fill = gendercat)) + 
  geom_bar(position=position_dodge(), stat="count",
           colour="black", # Use black outlines,
           size=.3) +
  xlab("Condition") +
  ylab("Count") +
  ggtitle("Gender by Condition") +
  theme_bw(base_size = 11)

table(d$gendercat, d$manipcond)
chisq.test(table(d$gendercat, d$manipcond))


# Income 
ggplot(d[!is.na(d$incomecat), ], aes(x=condition, fill = incomecat)) + #remove the NAs from income
  geom_bar(position=position_dodge(), stat="count",
           colour="black", # Use black outlines,
           size=.3) +
  xlab("Condition") +
  ylab("Count") +
  ggtitle("Household income by Condition") +
  theme_bw(base_size = 11)

table(d$incomecat, d$condition)
chisq.test(table(d$incomecat, d$condition))

# Education

ggplot(d[!is.na(d$educat), ], aes(x=condition, fill = educat)) + #remove the NAs from income
  geom_bar(position=position_dodge(), stat="count",
           colour="black", # Use black outlines,
           size=.3) +
  xlab("Condition") +
  ylab("Count") +
  ggtitle("Education by Condition") +
  theme_bw(base_size = 11)

table(d$educat, d$condition)
chisq.test(table(d$educat, d$condition))

# Race

ggplot(d[!is.na(d$racecat), ], aes(x=condition, fill = racecat)) + #remove the NAs from income
  geom_bar(position=position_dodge(), stat="count",
           colour="black", # Use black outlines,
           size=.3) +
  xlab("Condition") +
  ylab("Count") +
  ggtitle("Race by Condition") +
  theme_bw(base_size = 11)

table(d$racecat, d$condition)
chisq.test(table(d$racecat, d$condition))
```



**Examining correlations among variables**

&nbsp; &nbsp; &nbsp; &nbsp; I am also interested in exploring correlations among the independent variables, demographic variables, dependent variables, and reaction time to the dependent variables to determine whether we should pursue any analyses. I am also interested in exploring whether time to wait and total savings covary.

```{r warning = FALSE, message = FALSE, eval = FALSE, fig.width=4, fig.height=3}
d$gender = as.numeric(d$gender)
d$edu = as.numeric(d$edu)
d$income = as.numeric(d$income)
d$race = as.numeric(d$race)

cor(d[, c("conditionnum", "age", "gender", "income", "edu", "race", "delaytimeyrs", "savingtot", "delay.rt", "savings.rt")])
cov(d[, c("delaytimeyrs", "savingtot")]) #covariance between when to save and how much
#d0 = na.omit(d)
#cor(d0[, c("conditionnum", "age", "gender", "income", "edu", "race", "delaytimeyrs", "savingtot", "delay.rt", "savings.rt")])
#cov(d0[, c("delaytimeyrs", "savingtot")])
```


&nbsp; &nbsp; &nbsp; &nbsp; Age, income, and education are all plausibly linked to retirement savings, so I am interested in examining those relationships, especially through visual inspection.

```{r warning = FALSE, message = FALSE, eval = FALSE, fig.width=5, fig.height=3}

## When to save

rslm.incdelay = lm(delaytimeyrs ~ income, d)
#rslm.incdelay$coefficients
ggplot(d, aes(incomecat, delaytimeyrs)) +
  geom_point(aes()) +
  geom_abline(intercept = rslm.incdelay$coefficients[1], slope = rslm.incdelay$coefficients[2]) +
  xlab("Household income") +
  ylab("When should you save?") +
  theme_linedraw(base_size = 12) + 
  theme(axis.text.x = element_text(angle = 20, hjust = 1)) 

rslm.edudelay = lm(delaytimeyrs ~ income, d)
#rslm.edudelay$coefficients
ggplot(d, aes(educat, delaytimeyrs)) +
  geom_point(aes()) +
  geom_abline(intercept = rslm.edudelay$coefficients[1], slope = rslm.edudelay$coefficients[2]) +
  xlab("Education") +
  ylab("When should you save?") +
  theme_linedraw(base_size = 12) + 
  theme(axis.text.x = element_text(angle = 20, hjust = 1)) 

rslm.agedelay = lm(delaytimeyrs ~ age, d)
#rslm.agedelay$coefficients
ggplot(d, aes(age, delaytimeyrs)) +
  geom_point(aes()) +
  geom_abline(intercept = rslm.agedelay$coefficients[1], slope = rslm.agedelay$coefficients[2]) +
  xlab("Age") +
  ylab("When should you save?") +
  theme_linedraw(base_size = 12)
```

```{r warning = FALSE, message = FALSE, eval = FALSE, fig.width=4, fig.height=3}

## How much to save

rslm.incsaving = lm(savingtot ~ income, d) # Relationship in original paper
#rslm.incsaving$coefficients
ggplot(d, aes(incomecat, savingtot)) +
  geom_point(aes()) +
  geom_abline(intercept = rslm.incsaving$coefficients[1], slope = rslm.incsaving$coefficients[2]) +
  xlab("Household income") +
  ylab("Total savings ($)") +
  theme_linedraw(base_size = 12) + 
  theme(axis.text.x = element_text(angle = 20, hjust = 1)) 

rslm.edusaving = lm(savingtot ~ edu, d)
#rslm.edusaving$coefficients
ggplot(d, aes(educat, savingtot)) +
  geom_point(aes()) +
  geom_abline(intercept = rslm.edusaving$coefficients[1], slope = rslm.edusaving$coefficients[2]) +
  xlab("Education") +
  ylab("Total savings ($)") +
  theme_linedraw(base_size = 12) + 
  theme(axis.text.x = element_text(angle = 20, hjust = 1)) 

rslm.agesaving = lm(savingtot ~ age, d)
#rslm.agesaving$coefficients
ggplot(d, aes(age, savingtot)) +
  geom_point(aes()) +
  geom_abline(intercept = rslm.agesaving$coefficients[1], slope = rslm.agesaving$coefficients[2]) +
  xlab("Age") +
  ylab("Total savings ($)") +
  theme_linedraw(base_size = 12)
```


------

<center>**References**</center>
<br>Ipeirotis, P. (2015). Demographics of Mechanical Turk: Now Live! (April 2015 edition). Retrieved January 31, 2015 from http://www.behind-the-enemy-lines.com/2015/04/demographics-of-mechanical-turk-now.html 
<br>Lewis, N. A., & Oyserman, D. (2015). When does the future begin? Time metrics matter, connecting present and future selves. *Psychological Science, 26*(6), 816-825.
  
  

